{"version":3,"sources":["annotations.js"],"names":[],"mappings":"AAAA,KAAO,EAAC,KAAI,CAAC,KAAO,2BAAyB,CAAC;AAY9C,KAAO,MAAM,OAAK;AAEhB,AACA,YAAU,CAAE,KAAI,CAAG;AACjB,OAAG,MAAM,EAAI,MAAI,CAAC;EACpB;AAAA,AACF;AAAA,AAlBA,KAAK,eAAe,AAAC,uBACb,EAAC,GAAE,CAAG,UAAS,AAAD,CAAG;AAAC,cAavB,MAAI,AAAC,EAAC,EAbwC;EAAC,CAAC,CAAC,CAAC;AA+BrD,KAAO,MAAM,cAAY;AAEvB,AACA,YAAU,CAAE,KAAI,CAAG;AACjB,OAAG,MAAM,EAAI,MAAI,CAAC;EACpB;AAAA,AACF;AAAA,AAtCA,KAAK,eAAe,AAAC,8BACb,EAAC,GAAE,CAAG,UAAS,AAAD,CAAG;AAAC,cAiCvB,MAAI,AAAC,EAAC,EAjCwC;EAAC,CAAC,CAAC,CAAC;AAmDrD,KAAO,MAAM,WAAS;AAEpB,AACA,YAAU,CAAE,KAAI,CAAG;AACjB,OAAG,MAAM,EAAI,MAAI,CAAC;EACpB;AAAA,AACF;AAAA,AA1DA,KAAK,eAAe,AAAC,2BACb,EAAC,GAAE,CAAG,UAAS,AAAD,CAAG;AAAC,cAqDvB,MAAI,AAAC,EAAC,EArDwC;EAAC,CAAC,CAAC,CAAC;AAuErD,KAAO,MAAM,SAAO;AAClB,AACA,YAAU,CAAE,AAAD,CAAG,GACd;AAAA,AACF;AAAA,AA5EA,KAAK,eAAe,AAAC,yBACb,EAAC,GAAE,CAAG,UAAS,AAAD,CAAG;AAAC,cAwEvB,MAAI,AAAC,EAAC,EAxEwC;EAAC,CAAC,CAAC,CAAC;AAwGrD,KAAO,MAAM,qBAAmB;AAC9B,AACA,YAAU,CAAE,AAAD,CAAG,GACd;AAAA,AAEA,IAAI,MAAI,EAAI;AACV,SAAO,KAAG,CAAC;EACb;AAAA,AACF;AAAA,AAjHA,KAAK,eAAe,AAAC,qCACb,EAAC,GAAE,CAAG,UAAS,AAAD,CAAG;AAAC,cAyGvB,MAAI,AAAC,EAAC,EAzGwC;EAAC,CAAC,CAAC,CAAC;AA+HrD,KAAO,MAAM,WAAS;AACpB,AACA,YAAU,CAAE,AAAD,CAAG,GACd;AAAA,AACF;AAAA,AApIA,KAAK,eAAe,AAAC,2BACb,EAAC,GAAE,CAAG,UAAS,AAAD,CAAG;AAAC,cAgIvB,MAAI,AAAC,EAAC,EAhIwC;EAAC,CAAC,CAAC,CAAC;AAoIrD","file":"angular2/src/di/annotations.es6","sourcesContent":["import {CONST} from \"angular2/src/facade/lang\";\n\n/**\n * A parameter annotation that creates a synchronous eager dependency.\n *\n * ```\n * class AComponent {\n *   constructor(@Inject('aServiceToken') aService) {}\n * }\n * ```\n *\n */\nexport class Inject {\n  token;\n  @CONST()\n  constructor(token) {\n    this.token = token;\n  }\n}\n\n/**\n * A parameter annotation that creates an asynchronous eager dependency.\n *\n * ```\n * class AComponent {\n *   constructor(@InjectPromise('aServiceToken') aServicePromise) {\n *     aServicePromise.then(aService => ...);\n *   }\n * }\n * ```\n *\n */\nexport class InjectPromise {\n  token;\n  @CONST()\n  constructor(token) {\n    this.token = token;\n  }\n}\n\n/**\n * A parameter annotation that creates a synchronous lazy dependency.\n *\n * ```\n * class AComponent {\n *   constructor(@InjectLazy('aServiceToken') aServiceFn) {\n *     aService = aServiceFn();\n *   }\n * }\n * ```\n *\n */\nexport class InjectLazy {\n  token;\n  @CONST()\n  constructor(token) {\n    this.token = token;\n  }\n}\n\n/**\n * A parameter annotation that marks a dependency as optional.\n *\n * ```\n * class AComponent {\n *   constructor(@Optional() dp:Dependency) {\n *     this.dp = dp;\n *   }\n * }\n * ```\n *\n */\nexport class Optional {\n  @CONST()\n  constructor() {\n  }\n}\n\n/**\n * `DependencyAnnotation` is used by the framework to extend DI.\n *\n * Only annotations implementing `DependencyAnnotation` will be added\n * to the list of dependency properties.\n *\n * For example:\n *\n * ```\n * class Parent extends DependencyAnnotation {}\n * class NotDependencyProperty {}\n *\n * class AComponent {\n *   constructor(@Parent @NotDependencyProperty aService:AService) {}\n * }\n * ```\n *\n * will create the following dependency:\n *\n * ```\n * new Dependency(Key.get(AService), [new Parent()])\n * ```\n *\n * The framework can use `new Parent()` to handle the `aService` dependency\n * in a specific way.\n *\n */\nexport class DependencyAnnotation {\n  @CONST()\n  constructor() {\n  }\n\n  get token() {\n    return null;\n  }\n}\n\n/**\n * A class annotation that marks a class as available to `Injector`s for\n * creation.\n *\n * ```\n * class NeedsService {\n *   constructor(svc:UsefulService) {}\n * }\n *\n * @Injectable\n * class UsefulService {}\n * ```\n */\nexport class Injectable {\n  @CONST()\n  constructor() {\n  }\n}\n"]}