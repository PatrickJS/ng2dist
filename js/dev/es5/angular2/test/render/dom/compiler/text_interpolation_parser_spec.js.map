{"version":3,"sources":["text_interpolation_parser_spec.es6"],"names":[],"mappings":"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","file":"angular2/test/render/dom/compiler/text_interpolation_parser_spec.js","sourcesContent":["import {describe,\n  beforeEach,\n  expect,\n  it,\n  iit,\n  ddescribe,\n  el} from 'angular2/test_lib';\nimport {TextInterpolationParser} from 'angular2/src/render/dom/compiler/text_interpolation_parser';\nimport {CompilePipeline} from 'angular2/src/render/dom/compiler/compile_pipeline';\nimport {MapWrapper,\n  ListWrapper} from 'angular2/src/facade/collection';\nimport {Lexer,\n  Parser} from 'angular2/change_detection';\nimport {IgnoreChildrenStep} from './pipeline_spec';\nexport function main() {\n  describe('TextInterpolationParser', () => {\n    function createPipeline() {\n      return new CompilePipeline([new IgnoreChildrenStep(), new TextInterpolationParser(new Parser(new Lexer()))]);\n    }\n    function process(element) {\n      return ListWrapper.map(createPipeline().process(element), (compileElement) => compileElement.inheritedElementBinder);\n    }\n    function assertTextBinding(elementBinder, bindingIndex, nodeIndex, expression) {\n      expect(elementBinder.textBindings[bindingIndex].source).toEqual(expression);\n      expect(elementBinder.textBindingIndices[bindingIndex]).toEqual(nodeIndex);\n    }\n    it('should find text interpolation in normal elements', () => {\n      var result = process(el('<div>{{expr1}}<span></span>{{expr2}}</div>'))[0];\n      assertTextBinding(result, 0, 0, \"{{expr1}}\");\n      assertTextBinding(result, 1, 2, \"{{expr2}}\");\n    });\n    it('should find text interpolation in template elements', () => {\n      var result = process(el('<template>{{expr1}}<span></span>{{expr2}}</template>'))[0];\n      assertTextBinding(result, 0, 0, \"{{expr1}}\");\n      assertTextBinding(result, 1, 2, \"{{expr2}}\");\n    });\n    it('should allow multiple expressions', () => {\n      var result = process(el('<div>{{expr1}}{{expr2}}</div>'))[0];\n      assertTextBinding(result, 0, 0, \"{{expr1}}{{expr2}}\");\n    });\n    it('should not interpolate when compileChildren is false', () => {\n      var results = process(el('<div>{{included}}<span ignore-children>{{excluded}}</span></div>'));\n      assertTextBinding(results[0], 0, 0, \"{{included}}\");\n      expect(results[1]).toBe(results[0]);\n    });\n    it('should allow fixed text before, in between and after expressions', () => {\n      var result = process(el('<div>a{{expr1}}b{{expr2}}c</div>'))[0];\n      assertTextBinding(result, 0, 0, \"a{{expr1}}b{{expr2}}c\");\n    });\n    it('should escape quotes in fixed parts', () => {\n      var result = process(el(\"<div>'\\\"a{{expr1}}</div>\"))[0];\n      assertTextBinding(result, 0, 0, \"'\\\"a{{expr1}}\");\n    });\n  });\n}\n//# sourceMappingURL=text_interpolation_parser_spec.js.map\n\n//# sourceMappingURL=./text_interpolation_parser_spec.map"]}