{"version":3,"sources":["visibility.js"],"names":[],"mappings":"AAAA;AAAA,KAAK,iBAAiB,AAAC,CAAC,MAAK,QAAQ;QAArC,EAAC,GAAE,YAAqB;AAAE,mBAAwB;IAAE,AAA9B,CAAC;UAAvB,EAAC,GAAE,YAAqB;AAAE,qBAAwB;IAAE,AAA9B,CAAC;AAAvB,WAAS,CAAT,EAAC,KAAI,CAAO,KAAG,AAAS,CAAC;CAAgC,CAAC;;;EAAlD,MAAI,EAAZ,EAAC,wCAAoB,CAAA,OAAM,AAAC,4BAAkB,CACtC,CAAA,yCAAqB,kDAA2B,CAAA,yCAAqB,GAAK,EAAC,OAAM,wCAAmB,CAAC,AAD/D,CACgE;EAAtG,qBAAmB,EAD3B,EAAC,qBAAoB,CAAA,OAAM,AAAC,eAAkB,CACtC,CAAA,sBAAqB,+BAA2B,CAAA,sBAAqB,GAAK,EAAC,OAAM,qBAAmB,CAAC,AAD/D,CACgE;AAD9G,AAAI,EAAA,SA4CG,SAAM,OAAK,CAEJ,AAAD,CAAG;AACZ,AA/CJ,gBAAc,iBAAiB,AAAC,SAAkB,KAAK,MAAmB,CA+C/D;AACT,AAhDsC,CAAA;AAAxC,AAAI,EAAA,iBAAoC,CAAA;AAAxC,AAAC,eAAc,YAAY,CAAC,AAAC,gBA4CD,qBAAmB,CA3CS;AADxD,KAAK,eAAe,AAAC,uBACb,EAAC,GAAE,CAAG,UAAS,AAAD,CAAG;AAAC,cA4CvB,MAAI,AAAC,EAAC,EA5CwC;EAAC,CAAC,CAAC,CAAC;AADrD,AAAI,EAAA,WAyGG,SAAM,SAAO,CAEN,AAAD,CAAG;AACZ,AA5GJ,gBAAc,iBAAiB,AAAC,WAAkB,KAAK,MAAmB,CA4G/D;AACT,AA7GsC,CAAA;AAAxC,AAAI,EAAA,qBAAoC,CAAA;AAAxC,AAAC,eAAc,YAAY,CAAC,AAAC,kBAyGC,qBAAmB,CAxGO;AADxD,KAAK,eAAe,AAAC,yBACb,EAAC,GAAE,CAAG,UAAS,AAAD,CAAG;AAAC,cAyGvB,MAAI,AAAC,EAAC,EAzGwC;EAAC,CAAC,CAAC,CAAC;AA8GrD","file":"angular2/src/core/annotations/visibility.js","sourcesContent":["import {CONST} from 'angular2/src/facade/lang';\nimport {DependencyAnnotation} from 'angular2/di';\n\n/**\n * Specifies that an injector should retrieve a dependency from the direct parent.\n *\n * ## Example\n *\n * Here is a simple directive that retrieves a dependency from its parent element.\n *\n * ```\n * @Decorator({\n *   selector: '[dependency]',\n *   properties: {\n *     'id':'dependency'\n *   }\n * })\n * class Dependency {\n *   id:string;\n * }\n *\n *\n * @Decorator({\n *   selector: '[my-directive]'\n * })\n * class Dependency {\n *   constructor(@Parent() dependency:Dependency) {\n *     expect(dependency.id).toEqual(1);\n *   };\n * }\n * ```\n *\n * We use this with the following HTML template:\n *\n * ```\n * <div dependency=\"1\">\n *   <div dependency=\"2\" my-directive></div>\n * </div>\n * ```\n * The `@Parent()` annotation in our constructor forces the injector to retrieve the dependency from the\n * parent element (even thought the current element could resolve it): Angular injects `dependency=1`.\n *\n * @exportedAs angular2/annotations\n */\nexport class Parent extends DependencyAnnotation {\n  @CONST()\n  constructor() {\n    super();\n  }\n}\n\n/**\n * Specifies that an injector should retrieve a dependency from any ancestor element.\n *\n * An ancestor is any element between the parent element and shadow root.\n *\n *\n * ## Example\n *\n * Here is a simple directive that retrieves a dependency from an ancestor element.\n *\n * ```\n * @Decorator({\n *   selector: '[dependency]',\n *   properties: {\n *     'id':'dependency'\n *   }\n * })\n * class Dependency {\n *   id:string;\n * }\n *\n *\n * @Decorator({\n *   selector: '[my-directive]'\n * })\n * class Dependency {\n *   constructor(@Ancestor() dependency:Dependency) {\n *     expect(dependency.id).toEqual(2);\n *   };\n * }\n * ```\n *\n *  We use this with the following HTML template:\n *\n * ```\n * <div dependency=\"1\">\n *   <div dependency=\"2\">\n *     <div>\n *       <div dependency=\"3\" my-directive></div>\n *     </div>\n *   </div>\n * </div>\n * ```\n *\n * The `@Ancestor()` annotation in our constructor forces the injector to retrieve the dependency from the\n * nearest ancestor element:\n * - The current element `dependency=\"3\"` is skipped because it is not an ancestor.\n * - Next parent has no directives `<div>`\n * - Next parent has the `Dependency` directive and so the dependency is satisfied.\n *\n * Angular injects `dependency=2`.\n *\n * @exportedAs angular2/annotations\n */\nexport class Ancestor extends DependencyAnnotation {\n  @CONST()\n  constructor() {\n    super();\n  }\n}\n"]}